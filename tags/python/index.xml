<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on わいがかいた</title>
    <link>https://pyonk.github.io/blog/tags/python/</link>
    <description>Recent content in Python on わいがかいた</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 20 Feb 2019 15:12:08 +0900</lastBuildDate>
    
	<atom:link href="https://pyonk.github.io/blog/tags/python/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Django Test Client Url Capture Not Working</title>
      <link>https://pyonk.github.io/blog/posts/django-test-client-url-capture-not-working/</link>
      <pubDate>Wed, 20 Feb 2019 15:12:08 +0900</pubDate>
      
      <guid>https://pyonk.github.io/blog/posts/django-test-client-url-capture-not-working/</guid>
      <description>from django.urls import path url_patterns = [ path(&#39;users/&amp;lt;int:user_id&amp;gt;/&#39;, views.show, name=&#39;user_show&#39;), ]  from django.test import TestCase, RequestFactory from users import views from django.contrib.auth.models import AnonymousUser from django.contrib.sessions.middleware import SessionMiddleware from django.contrib.messages.middleware import MessageMiddleware class UserViewTestCase(TestCase): def setUp(self): self.request = RequestFactory() def test_access_user_page(self): user_id = 1 req = self.request.get( reverse(&#39;user_show&#39;, args=(user_id,)) ) req.user = AnonymousUser() SessionMiddleware().process_request(req) MessageMiddleware().process_request(req) res = views.show(req) self.assertTrue(res.status_code, 302)  上記のようなテストコードがあったとすると views.showでself.kwargs[&#39;user_id&#39;]が参照できないっていう状況に1時間くらいハマった
結論から言うと RequestFactoryは単純にrequestオブジェクトを作るだけなので、urlsとか関係なく views.show(req)をテストしてるに過ぎないと言うことだった なので views.show(req, user_id=user_id)としてあげると良かったようだ</description>
    </item>
    
    <item>
      <title>facebookのためにsocial loginをごにょごにょした話</title>
      <link>https://pyonk.github.io/blog/posts/social-login-update-for-facebook/</link>
      <pubDate>Wed, 20 Dec 2017 13:54:50 +0900</pubDate>
      
      <guid>https://pyonk.github.io/blog/posts/social-login-update-for-facebook/</guid>
      <description>facebookに見慣れぬアラートが。  突然のアラート    難しい英文    In 90 days, we&amp;rsquo;re making a security update to Facebook Login that will invalidate calls from URIs not listed in the Valid OAuth redirect URIs field of your Facebook Login settings.
This update comes in response to malicious activity we saw on our platform, and we want to protect your app or website by requiring a new strict mode for redirect URIs.</description>
    </item>
    
    <item>
      <title>djangoのquerysetを任意の順番でsortする</title>
      <link>https://pyonk.github.io/blog/posts/django-queryset-order-by-specific-values/</link>
      <pubDate>Fri, 10 Nov 2017 18:33:41 +0900</pubDate>
      
      <guid>https://pyonk.github.io/blog/posts/django-queryset-order-by-specific-values/</guid>
      <description>djangoのquerysetを任意の順番でsortする djnagoではorder_by(&#39;hoge&#39;)とするとhogeの昇順でならんでいくことは当たり前のように知っているよね。
が、ぼくがやりたかったのは、任意の値でのソート。
databaseに定義されてない値でソートしたかったのです。
とても参考になったstack overflowはこちら。
Django order_by specific order - Stack Overflow
 ただしdjango &amp;gt;= 1.8です
 TL;DR from djnago.db.models import Case, When, Value, FloatField # { pid: specific_value, } specific_values = { &#39;1&#39;: 100.0, &#39;2&#39;: 50.0, &#39;3&#39;: 25.0, &#39;4&#39;: 123.4, &#39;5&#39;: 599.33, } # sqlのCASE式にしたい条件のリスト cases = [] # casesにCASE式にしたい条件をつめていく for pid, specific_value in specific_values.items(): cases.append(When(id=pid, then=Value(specific_value))) # Hogeモデルに対して、pidで絞り込んだあとにcasesをつかってspecific_valueについて注釈づけてorder_byする Hoge.objects.filter(id__in=specific_values.keys()).annotate(specific_value=Case( *cases, output_field=FloatField() )).order_by(specific_value)  詳しい説明 Conditional Expressions | Django documentation | Django</description>
    </item>
    
    <item>
      <title>sublimetextでvimを使いたい日本人にとっておそらく便利なパッケージをつくった</title>
      <link>https://pyonk.github.io/blog/posts/create-disabled-ime-command-for-subl-with-vintage/</link>
      <pubDate>Wed, 18 Oct 2017 10:23:34 +0900</pubDate>
      
      <guid>https://pyonk.github.io/blog/posts/create-disabled-ime-command-for-subl-with-vintage/</guid>
      <description>ぼくは普段からsublimetextを使っているのだけど
（最近のアップデートでタイトルバーの色も変えられるようになってご機嫌）、vimに強い憧れがあって、使ってみたいなあと日頃から思っていた。
vim使ってる人のプロフェッショナル感がすごい。
sublでもとりあえずキーバインドはvimにして、触ってみよって思ってデフォルトでは無効になってるVintageを有効化した。
Vintageの有効化 Cmd + ,でsublimetextの設定を開く。
ここのVintageを消す。
 vintage消す   有効化done
つかってみる つかってみるとわかるんだけど、IMEがONの状態でINSERT MODEからCOMMAND MODEに移行するとIMEがONのままでコマンドを受け付けなくなるのですね
 こんな具合ですね   INSERT MODEからCOMMAND MODEに移行するためにescapeを押下するんだけど、そのときにIMEをOFFにすれば良いですね。
ちなみにgoogle日本語入力だとescapeを押下するときにIMEを無効にする設定があります。
 VimでNormalモード切り替え時にIMEをOFFにする、をMacでKarabiner無しで実現する 3  カラビナ使うっていう手もあるけど
できればパッケージで完結したいなと思って色々調べたら似たようなのがありました。
macではAppleScriptを使うみたいですね。
 SublimeText 3のVintageでコマンドモードの時にIMEをOffにするWin&amp;amp;Mac - Qiita  僕は拗らせているので、macのUS配列を使っているから上記のパッケージでは対応できず。
タイトルでは作ってみたって書いたけど、実際は機能追加だけです。タイトル詐欺。
で結果はこうなります。
 こんな具合ですね   おソース  pyonk/DisabledIme  こちらにおいてありますので、git cloneしてお使いくださいませ。</description>
    </item>
    
    <item>
      <title>pythonからpdfのフォームに入力する</title>
      <link>https://pyonk.github.io/blog/posts/fill-pdf-form-from-python/</link>
      <pubDate>Thu, 05 Oct 2017 15:46:45 +0900</pubDate>
      
      <guid>https://pyonk.github.io/blog/posts/fill-pdf-form-from-python/</guid>
      <description>pythonからpdfのフォームに入力する（厳密には違う） pythonでpdfのフォームに値を入力していく機能をつくりました。
そもそもpdfにフォームなんて埋められるんだって知らなかったです。
どうやら読み込み専用フォームとそうでないフォームがあるみたいです。
書き込めるフォームであってもフォントの指定や色付けとかが難しそうだったので、フォームに入力しない形式で実装しました。
なのでどちらにも対応できるような感じになってます。
事前準備  reportlab
$ pip install reportlab  PyPDF2
$ pip install pypdf2   コード #! /usr/bin/python # -*- coding: utf-8 -*- from reportlab.pdfgen import canvas from reportlab.lib.pagesizes import A4 from reportlab.pdfbase import pdfmetrics from reportlab.pdfbase.ttfonts import TTFont from PyPDF2.pdf import PdfFileReader, PdfFileWriter from io import BytesIO title = &#39;title&#39; # fontを変更 pdfmetrics.registerFont(TTFont(&#39;Mplus1p-Light&#39;, &#39;static/font/Mplus1p/Mplus1p-Light.ttf&#39;)) template_path = &#39;template.pdf&#39; # 読み込み reader = PdfFileReader(template_path) existing_page = reader.</description>
    </item>
    
    <item>
      <title>あ！ やせいの requests.exceptions.SSLErrorが とびだしてきた！</title>
      <link>https://pyonk.github.io/blog/posts/cannot-request/</link>
      <pubDate>Thu, 02 Feb 2017 18:40:16 +0900</pubDate>
      
      <guid>https://pyonk.github.io/blog/posts/cannot-request/</guid>
      <description>あるサイトをクロールして情報を集めようと思ってpythonでプログラムを書いていたのですが、思わぬところでハマったので備忘録代わりに。
ナゾのrequests.exceptions.SSLError それなりにpythonのrequestsをつかってクローラーを書いていたのですぐできるワイヤ。と思っていたのですが、実行した途端にナゾのrequests.exceptions.SSLErrorが発生しました。
requests.exceptions.SSLError: hostname &#39;damedayo.com&#39; doesn&#39;t match either of &#39;www.kore.com&#39;, &#39;kore.com&#39;
おやおや、SSLErrorですから、なにかセキュリティ周りのエラーであることが予測できます。 さらにホスト名が違うことから、バーチャルホストを利用しているためにSSL証明書のhostが違うよっていうことなんでしょうか。
とりあえずverify=Falseを指定しても一度チャレンジです。
import requests req = requests.get(&#39;https://damedayo.com/&#39;, verify=False) print req.text  するとresponseが帰ってきました。
The client software did not provide a hostname using Server Name Indication (SNI), which is required to access this server.
はーーーーんんんんんんん
何はともあれ、ググります。
みっけた。
ん〜〜〜やはりバーチャルホスト周りっぽい。 というかpythonのバージョンが2.7.9以上であれば問題ないんか。コレ。
解決策としてStack Overflowへのリンクが貼ってありますね。こういうこともあるのね。初めて見た。
pip install pyOpenSSLで詰む pyOpenSSLとidnaをインストールしてあげるとよいよってあるのでやってみました。
idnaはすっきり入ってくれたのですがpyOpenSSLが上手くいかない。。(すでに入っていたためバージョンをあげています。)
$ pip install pyOpenSSL --upgrade .....前略..... 1 warning and 20 errors generated. error: command &#39;cc&#39; failed with exit status 1 ---------------------------------------- Failed building wheel for cryptography .</description>
    </item>
    
    <item>
      <title>pythonの参照渡しをどうすれば回避できるのか</title>
      <link>https://pyonk.github.io/blog/posts/python-copy/</link>
      <pubDate>Thu, 12 Jan 2017 18:21:36 +0900</pubDate>
      
      <guid>https://pyonk.github.io/blog/posts/python-copy/</guid>
      <description>ときたまpythonを書いているとこれって値渡しなんだっけ、参照渡しなんだっけと分からなくなります。 たとえば
hoge = {1:1, 2:2, 3:3} print id(hoge) # 140418104920496 fuga = hoge print id(fuga) # 140418104920496 fuga.update({ 4:4 }) print hoge == fuga # True  Pythonistなら常識ですよね。
どうすれば回避できるのか 割と単純です。
hoge = {1:1, 2:2, 3:3} print id(hoge) # 140418104920496 fuga = hoge.copy() print id(fuga) # 140418107009728 fuga.update({ 4:4 }) print hoge == fuga # False print hoge # {1:1, 2:2, 3:3} print fuga # {1:1, 2:2, 3:3, 4:4}  辞書の浅いコピーを取るにはcopy_dict = dict.</description>
    </item>
    
    <item>
      <title>Djangoでどうしても非同期でコマンドを実行したくなった</title>
      <link>https://pyonk.github.io/blog/posts/use-celery-for-send-email-django/</link>
      <pubDate>Fri, 06 Jan 2017 12:05:29 +0900</pubDate>
      
      <guid>https://pyonk.github.io/blog/posts/use-celery-for-send-email-django/</guid>
      <description>経緯 あるサイトで、顧客に新情報をメールでお知らせしたいときに、今まではコマンド叩いて送信していたのですが、結構面倒なのでブラウザからできないものかと試行錯誤していたのです。
コマンドの設計見直せっていうのは今回は置いといてください・・・。
どうしたのか いくつかの方法を試しました。
pythonからコマンドを叩く まず思い浮かんだのがコマンドをnohup &amp;amp;でpythonから叩く。
import subprocess import shlex cmd = &#39;nohup sleep 10 &amp;amp;&#39; subprocess.Popen(cmd)  が！！！ レスポンスが帰ってくるのは10秒後・・・。
つぎ！
thread化して逃げる この前書いたような感じです。
pythonでtupleをつくる - わいがかいた
結局、レスポンスが帰ってくるのは10秒後・・・。 ここ工夫するとどうにかなるような気もする。
つぎ！！
celeryを使う Celery - Distributed Task Queue — Celery 4.0.2 documentation
ようやく本題。
ググり始めた当初から名前を見かけてはいましたが敷居が高そうなのでスルーしてました。
実際やりはじめて少し後悔しましたし。
結構面倒くさかったので備忘録代わりに。
install まずは本体をインストールしていきます。
pip install -U Celery
celeryはbrokerとして * Redis * RabbitMQ * Amazon SQS
などを使うことができます。 今回はRedisを選択しました。
yum install redis
bundleも用意されているのでそれも。
pip install -U &amp;quot;celery[redis]&amp;quot;</description>
    </item>
    
    <item>
      <title>pythonでtupleをつくる</title>
      <link>https://pyonk.github.io/blog/posts/python-tuple/</link>
      <pubDate>Thu, 05 Jan 2017 15:05:43 +0900</pubDate>
      
      <guid>https://pyonk.github.io/blog/posts/python-tuple/</guid>
      <description>pythonのthreadで引数を渡したい Djangoで時間のかかる処理をスレッド化して逃げようとしたのですがうまくいかなかったのでメモ。
threading.Threadにはいくつか引数が渡せます。
 group target name args kwargs  詳しくはここで。
で、スレッド化したい処理に引数を渡そうと思って下記のように実装しました。
def command_execute(cmd): print cmd # (&#39;s&#39;, &#39;l&#39;, &#39;e&#39;, &#39;e&#39;, &#39;p&#39;, &#39; &#39;, &#39;1&#39;, &#39;0&#39;, &#39;;&#39;, &#39;e&#39;, &#39;c&#39;, &#39;h&#39;, &#39;o&#39;, &#39; &#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;) subprocess.Popen(cmd, shell=True) return cmd = &#39;sleep 10;echo aaa&#39; t = threading.Thread(target=command_execute, args=(cmd)) t.daemon = True t.start()  すると、printされた文字列が (&#39;s&#39;, &#39;l&#39;, &#39;e&#39;, &#39;e&#39;, &#39;p&#39;, &#39; &#39;, &#39;1&#39;, &#39;0&#39;, &#39;;&#39;, &#39;e&#39;, &#39;c&#39;, &#39;h&#39;, &#39;o&#39;, &#39; &#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;) となるわけです。 何が起きてるんだ状態です。</description>
    </item>
    
  </channel>
</rss>