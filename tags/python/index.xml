<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on わいがかいた</title>
    <link>https://pyonk.github.io/blog/tags/python/</link>
    <description>Recent content in Python on わいがかいた</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <copyright>pyonk</copyright>
    <lastBuildDate>Thu, 02 Feb 2017 18:40:16 +0900</lastBuildDate>
    <atom:link href="https://pyonk.github.io/blog/tags/python/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>あ！ やせいの requests.exceptions.SSLErrorが とびだしてきた！</title>
      <link>https://pyonk.github.io/blog/post/yasei-no-sslerror/</link>
      <pubDate>Thu, 02 Feb 2017 18:40:16 +0900</pubDate>
      
      <guid>https://pyonk.github.io/blog/post/yasei-no-sslerror/</guid>
      <description>

&lt;p&gt;あるサイトをクロールして情報を集めようと思ってpythonでプログラムを書いていたのですが、思わぬところでハマったので備忘録代わりに。&lt;/p&gt;

&lt;h1 id=&#34;ナゾのrequests-exceptions-sslerror&#34;&gt;ナゾのrequests.exceptions.SSLError&lt;/h1&gt;

&lt;p&gt;それなりにpythonの&lt;a href=&#34;http://docs.python-requests.org/en/master/&#34;&gt;requests&lt;/a&gt;をつかってクローラーを書いていたのですぐできるワイヤ。と思っていたのですが、実行した途端にナゾの&lt;code&gt;requests.exceptions.SSLError&lt;/code&gt;が発生しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;requests.exceptions.SSLError: hostname &#39;damedayo.com&#39; doesn&#39;t match either of &#39;www.kore.com&#39;, &#39;kore.com&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;おやおや、SSLErrorですから、なにかセキュリティ周りのエラーであることが予測できます。
さらにホスト名が違うことから、バーチャルホストを利用しているためにSSL証明書のhostが違うよっていうことなんでしょうか。&lt;/p&gt;

&lt;p&gt;とりあえず&lt;code&gt;verify=False&lt;/code&gt;を指定しても一度チャレンジです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import requests
 
req = requests.get(&#39;https://damedayo.com/&#39;, verify=False)
print req.text
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;するとresponseが帰ってきました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The client software did not provide a hostname using Server Name Indication (SNI), which is required to access this server. 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;はーーーーんんんんんんん&lt;/p&gt;

&lt;p&gt;何はともあれ、ググります。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.python-requests.org/en/latest/community/faq/#what-are-hostname-doesn-t-match-errors&#34;&gt;みっけた&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;ん〜〜〜やはりバーチャルホスト周りっぽい。
というか&lt;strong&gt;pythonのバージョンが&lt;code&gt;2.7.9&lt;/code&gt;以上であれば問題ないんか&lt;/strong&gt;。コレ。&lt;/p&gt;

&lt;p&gt;解決策として&lt;a href=&#34;https://stackoverflow.com/questions/18578439/using-requests-with-tls-doesnt-give-sni-support/18579484#18579484&#34;&gt;Stack Overflowへのリンク&lt;/a&gt;が貼ってありますね。こういうこともあるのね。初めて見た。&lt;/p&gt;

&lt;h1 id=&#34;pip-install-pyopensslで詰む&#34;&gt;pip install pyOpenSSLで詰む&lt;/h1&gt;

&lt;p&gt;pyOpenSSLとidnaをインストールしてあげるとよいよってあるのでやってみました。&lt;/p&gt;

&lt;p&gt;idnaはすっきり入ってくれたのですがpyOpenSSLが上手くいかない。。(すでに入っていたためバージョンをあげています。)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ pip install pyOpenSSL --upgrade
.....前略.....
1 warning and 20 errors generated.
error: command &#39;cc&#39; failed with exit status 1

----------------------------------------
Failed building wheel for cryptography
.....中略.....
----------------------------------------
Command &amp;quot;/usr/bin/python -c &amp;quot;import setuptools, tokenize;__file__=&#39;/private/tmp/pip-build-OtiuE0/cryptography/setup.py&#39;;exec(compile(getattr(tokenize, &#39;open&#39;, open)(__file__).read().replace(&#39;\r\n&#39;, &#39;\n&#39;), __file__, &#39;exec&#39;))&amp;quot; install --record /tmp/pip-1pK2m3-record/install-record.txt --single-version-externally-managed --compile&amp;quot; failed with error code 1 in /private/tmp/pip-build-OtiuE0/cryptography
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gccがないよっていうのは見たことありましたが、ccがないよって初めて見ました。&lt;/p&gt;

&lt;p&gt;ともあれcryptographyのインストールに失敗しているみたいです。&lt;/p&gt;

&lt;p&gt;ぐぐります。&lt;/p&gt;

&lt;p&gt;例によって&lt;a href=&#34;http://stackoverflow.com/questions/22073516/failed-to-install-python-cryptography-package-with-pip-and-setup-py&#34;&gt;Stack Overflow&lt;/a&gt;です。&lt;/p&gt;

&lt;h2 id=&#34;opensslのアップデートで詰まる&#34;&gt;openSSLのアップデートで詰まる&lt;/h2&gt;

&lt;p&gt;openSSLのバージョンが古いのかもと思ってアップデートしました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew upgrade openssl
$ brew link openssl --force
Warning: Refusing to link: openssl
Linking keg-only openssl means you may end up linking against the insecure,
deprecated system OpenSSL while using the headers from Homebrew&#39;s openssl.
Instead, pass the full include/library paths to your compiler e.g.:
  -I/usr/local/opt/openssl/include -L/usr/local/opt/openssl/lib
$ which openssl
/usr/bin/openssl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ウーーン詰まる詰まる。&lt;/p&gt;

&lt;p&gt;いまはこの方法で&lt;a href=&#34;http://qiita.com/dasisyouyu/items/c9621c29b0fe79d2b7c4&#34;&gt;opensslへのリンクがはれない&lt;/a&gt;ようです。。&lt;/p&gt;

&lt;p&gt;PATHを通してあげます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export PATH=&amp;quot;/usr/local/opt/openssl/bin:$HOME/.pyenv/bin:$PATH&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;確認します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ which openssl
/usr/local/opt/openssl/bin/openssl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;つぎ！&lt;/p&gt;

&lt;h2 id=&#34;pipのアップデート&#34;&gt;pipのアップデート&lt;/h2&gt;

&lt;p&gt;さきほどのStack Overflowでは、pipのバージョンあげなよとあったのでアップデートです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ pip install --upgrade pip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さっくり詰まることなくクリアしました。&lt;/p&gt;

&lt;h2 id=&#34;そして大本営に突撃&#34;&gt;そして大本営に突撃&lt;/h2&gt;

&lt;p&gt;ようやくcryptograph(おぼえた)をインストールする手はずが整いました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ pip install pyOpenSSL --upgrade
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ばっちり！！アップデートできたっぽい！！！！&lt;/p&gt;

&lt;p&gt;いざ！！&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import requests
 
req = requests.get(&#39;https://damedayo.com/&#39;, verify=False)
print req.text
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;Traceback (most recent call last):
  File &amp;quot;eroge_translation_helpman.py&amp;quot;, line 3, in &amp;lt;module&amp;gt;
    import requests
  File &amp;quot;/Library/Python/2.7/site-packages/requests/__init__.py&amp;quot;, line 52, in &amp;lt;module&amp;gt;
    from .packages.urllib3.contrib import pyopenssl
  File &amp;quot;/Library/Python/2.7/site-packages/requests/packages/urllib3/contrib/pyopenssl.py&amp;quot;, line 48, in &amp;lt;module&amp;gt;
    from cryptography import x509
  File &amp;quot;/Library/Python/2.7/site-packages/cryptography/x509/__init__.py&amp;quot;, line 7, in &amp;lt;module&amp;gt;
    from cryptography.x509.base import (
  File &amp;quot;/Library/Python/2.7/site-packages/cryptography/x509/base.py&amp;quot;, line 15, in &amp;lt;module&amp;gt;
    from cryptography.hazmat.primitives.asymmetric import dsa, ec, rsa
  File &amp;quot;/Library/Python/2.7/site-packages/cryptography/hazmat/primitives/asymmetric/rsa.py&amp;quot;, line 14, in &amp;lt;module&amp;gt;
    from cryptography.hazmat.backends.interfaces import RSABackend
  File &amp;quot;/Library/Python/2.7/site-packages/cryptography/hazmat/backends/__init__.py&amp;quot;, line 7, in &amp;lt;module&amp;gt;
    import pkg_resources
  File &amp;quot;/Library/Python/2.7/site-packages/pkg_resources/__init__.py&amp;quot;, line 72, in &amp;lt;module&amp;gt;
    import packaging.requirements
  File &amp;quot;/Library/Python/2.7/site-packages/packaging/requirements.py&amp;quot;, line 59, in &amp;lt;module&amp;gt;
    MARKER_EXPR = originalTextFor(MARKER_EXPR())(&amp;quot;marker&amp;quot;)
TypeError: __call__() takes exactly 2 arguments (1 given)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;・・・・・・・・・・・。&lt;/p&gt;

&lt;p&gt;もう。&lt;/p&gt;

&lt;p&gt;ぐぐります・・・・・。&lt;/p&gt;

&lt;p&gt;見つけました。&lt;a href=&#34;http://stackoverflow.com/a/41841210&#34;&gt;Stack Overflow&lt;/a&gt;本当にありがとう。&lt;/p&gt;

&lt;p&gt;setuptoolsが原因だったみたいですね。バージョンによってはエラーが出るようです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ pip install setuptools == 33.1.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ということでこれでようやくプログラムを書き進められそうです。&lt;/p&gt;

&lt;h1 id=&#34;さいごに&#34;&gt;さいごに&lt;/h1&gt;

&lt;p&gt;というか&lt;code&gt;/etc/hosts&lt;/code&gt;をかえたらできたのではないか疑惑が・・・。&lt;/p&gt;

&lt;p&gt;さすがにないかしら。今度時間があったら試してみるでござる。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>pythonの参照渡しをどうすれば回避できるのか</title>
      <link>https://pyonk.github.io/blog/post/python-copy/</link>
      <pubDate>Thu, 12 Jan 2017 18:21:36 +0900</pubDate>
      
      <guid>https://pyonk.github.io/blog/post/python-copy/</guid>
      <description>

&lt;p&gt;ときたまpythonを書いているとこれって値渡しなんだっけ、参照渡しなんだっけと分からなくなります。
たとえば&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;hoge = {1:1, 2:2, 3:3}
print id(hoge) # 140418104920496

fuga = hoge
print id(fuga) # 140418104920496

fuga.update({
    4:4
})

print hoge == fuga # True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://note.crohaco.net/2014/python-argument-intro/&#34;&gt;Pythonistなら常識&lt;/a&gt;ですよね。&lt;/p&gt;

&lt;h1 id=&#34;どうすれば回避できるのか&#34;&gt;どうすれば回避できるのか&lt;/h1&gt;

&lt;p&gt;割と単純です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;hoge = {1:1, 2:2, 3:3}
print id(hoge) # 140418104920496

fuga = hoge.copy()
print id(fuga) # 140418107009728

fuga.update({
    4:4
})

print hoge == fuga # False

print hoge # {1:1, 2:2, 3:3}

print fuga # {1:1, 2:2, 3:3, 4:4}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;辞書の浅いコピーを取るには&lt;code&gt;copy_dict = dict.copy()&lt;/code&gt;が簡単ですね。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ちなみに、リストの場合は&lt;code&gt;copy_list = original_list[:]&lt;/code&gt;でコピーが取れます。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;ただこれだと浅いコピーになります。&lt;/p&gt;

&lt;p&gt;なので&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;hoge = {1:{2:2, 3:3}}
print id(hoge) # 140418104920496

fuga = hoge.copy()
print id(fuga) # 140418107009728

fuga[1].update({
    4:4
})

print hoge == fuga # True

print hoge # {1: {2: 2, 3: 3, 4: 4}}

print fuga # {1: {2: 2, 3: 3, 4: 4}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;となってしまいます。&lt;/p&gt;

&lt;p&gt;浅いコピーの場合は&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;元のオブジェクト中に見つかったオブジェクトに対する 参照 を挿入&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;するようです。&lt;/p&gt;

&lt;h1 id=&#34;深いコピー&#34;&gt;深いコピー&lt;/h1&gt;

&lt;p&gt;上記の通り、オブジェクトの中のオブジェクトは参照渡しになります。&lt;/p&gt;

&lt;p&gt;それを回避するために、copyモジュールをimportして、深いコピーを利用します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import copy

hoge = {1:{2:2, 3:3}}
print id(hoge) # 140418104920496

fuga = copy.deepcopy(hoge)
print id(fuga) # 140418107009728

fuga[1].update({
    4:4
})

print hoge == fuga # False

print hoge # {1: {2: 2, 3: 3}}

print fuga # {1: {2: 2, 3: 3, 4: 4}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あら素敵。&lt;/p&gt;

&lt;p&gt;結構厄介な場面も多いのできちんと覚えたいものです。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.python.jp/2.6/library/copy.html&#34;&gt;8.17. copy — 浅いコピーおよび深いコピー操作 — Python 2.6ja2 documentation&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Djangoでどうしても非同期でコマンドを実行したくなった</title>
      <link>https://pyonk.github.io/blog/post/use-celery-for-send-email-django/</link>
      <pubDate>Fri, 06 Jan 2017 12:05:29 +0900</pubDate>
      
      <guid>https://pyonk.github.io/blog/post/use-celery-for-send-email-django/</guid>
      <description>

&lt;h1 id=&#34;経緯&#34;&gt;経緯&lt;/h1&gt;

&lt;p&gt;あるサイトで、顧客に新情報をメールでお知らせしたいときに、今まではコマンド叩いて送信していたのですが、結構面倒なのでブラウザからできないものかと試行錯誤していたのです。&lt;/p&gt;

&lt;p&gt;コマンドの設計見直せっていうのは今回は置いといてください・・・。&lt;/p&gt;

&lt;h1 id=&#34;どうしたのか&#34;&gt;どうしたのか&lt;/h1&gt;

&lt;p&gt;いくつかの方法を試しました。&lt;/p&gt;

&lt;h2 id=&#34;pythonからコマンドを叩く&#34;&gt;pythonからコマンドを叩く&lt;/h2&gt;

&lt;p&gt;まず思い浮かんだのがコマンドを&lt;code&gt;nohup &amp;amp;&lt;/code&gt;でpythonから叩く。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import subprocess
import shlex

cmd = &#39;nohup sleep 10 &amp;amp;&#39;
subprocess.Popen(cmd)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;が！！！
レスポンスが帰ってくるのは10秒後・・・。&lt;/p&gt;

&lt;p&gt;つぎ！&lt;/p&gt;

&lt;h2 id=&#34;thread化して逃げる&#34;&gt;thread化して逃げる&lt;/h2&gt;

&lt;p&gt;この前書いたような感じです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://pyonk.github.io/blog/post/python-tuple/&#34;&gt;pythonでtupleをつくる - わいがかいた&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;結局、レスポンスが帰ってくるのは10秒後・・・。
ここ工夫するとどうにかなるような気もする。&lt;/p&gt;

&lt;p&gt;つぎ！！&lt;/p&gt;

&lt;h2 id=&#34;celeryを使う&#34;&gt;celeryを使う&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.celeryproject.org/en/latest/index.html&#34;&gt;Celery - Distributed Task Queue — Celery 4.0.2 documentation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ようやく本題。&lt;/p&gt;

&lt;p&gt;ググり始めた当初から名前を見かけてはいましたが敷居が高そうなのでスルーしてました。&lt;/p&gt;

&lt;p&gt;&lt;del&gt;実際やりはじめて少し後悔しましたし。&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;結構面倒くさかったので備忘録代わりに。&lt;/p&gt;

&lt;h3 id=&#34;install&#34;&gt;install&lt;/h3&gt;

&lt;p&gt;まずは本体をインストールしていきます。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pip install -U Celery&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;celeryはbrokerとして
* Redis
* RabbitMQ
* Amazon SQS&lt;/p&gt;

&lt;p&gt;などを使うことができます。
今回はRedisを選択しました。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;yum install redis&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;bundleも用意されているのでそれも。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pip install -U &amp;quot;celery[redis]&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;how-to&#34;&gt;how to&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/celery/celery/tree/master/examples/django/&#34;&gt;ここ&lt;/a&gt;を参考にモリモリかいていきます。&lt;/p&gt;

&lt;p&gt;proj/__init__.py&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from __future__ import absolute_import, unicode_literals

# This will make sure the app is always imported when
# Django starts so that shared_task will use this app.
from .celery import app as celery_app

__all__ = [&#39;celery_app&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;proj/settings.py&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Celery settings

CELERY_RESULT_BACKEND = &#39;redis&#39; # redisを指定
CELERY_BROKER_URL = &#39;redis://localhost:6379/0&#39;
CELERY_TASK_SERIALIZER = &#39;json&#39;
CELERY_RESULT_SERIALIZER = &#39;json&#39;
CELERY_ACCEPT_CONTENT = [&#39;json&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;proj/celery.py&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from __future__ import absolute_import, unicode_literals
import os
from celery import Celery

# set the default Django settings module for the &#39;celery&#39; program.
os.environ.setdefault(&#39;DJANGO_SETTINGS_MODULE&#39;, &#39;proj.settings&#39;)

app = Celery(&#39;proj&#39;)

# Using a string here means the worker don&#39;t have to serialize
# the configuration object to child processes.
# - namespace=&#39;CELERY&#39; means all celery-related configuration keys
#   should have a `CELERY_` prefix.
app.config_from_object(&#39;django.conf:settings&#39;, namespace=&#39;CELERY&#39;)

# Load task modules from all registered Django app configs.
app.autodiscover_tasks()


@app.task(bind=True)
def debug_task(self):
    print(&#39;Request: {0!r}&#39;.format(self.request))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;app/tasks.py&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#! /usr/bin/python
# -*- coding: utf-8 -*-
# Create your tasks here
from __future__ import absolute_import, unicode_literals
# from celery import shared_task
from celery.decorators import task
import time


@task()
def add_wait(x, y):
    time.sleep(10)
    return x + y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;app/views.py&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from tasks import add_wait
def add_some_number(request):
    result = add_wait.delay(2,3)
    return render(rerquest, &#39;result.html&#39;, {
        &#39;result&#39;: result,
    })
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;うごかしていきます&#34;&gt;うごかしていきます&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;redisの起動&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;sudo /etc/init.d/redis start&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;celeryの起動&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;celery -A proj worker&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;僕の環境はpythonのバージョンが&lt;code&gt;2.7.6&lt;/code&gt;なのですが、それだとエラーがおきます。&lt;/p&gt;

&lt;p&gt;というのもamqpというライブラリの中で使われている&lt;code&gt;struct.pack&lt;/code&gt;が原因のようです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/celery/kombu/issues/609&#34;&gt;struct Type Error when consume internal log message. · Issue #609 · celery/kombu&lt;/a&gt;をみるとスッキリします。&lt;/p&gt;

&lt;p&gt;どうやらpythonのバグのようですね。&lt;br /&gt;
&lt;a href=&#34;https://bugs.python.org/issue19099&#34;&gt;Issue 19099: struct.pack fails first time with unicode fmt - Python tracker&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;該当箇所を&lt;code&gt;str&lt;/code&gt;に変えてしまうと無事起動しました。&lt;/p&gt;

&lt;p&gt;疲れました。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>pythonでtupleをつくる</title>
      <link>https://pyonk.github.io/blog/post/python-tuple/</link>
      <pubDate>Thu, 05 Jan 2017 15:05:43 +0900</pubDate>
      
      <guid>https://pyonk.github.io/blog/post/python-tuple/</guid>
      <description>

&lt;h1 id=&#34;pythonのthreadで引数を渡したい&#34;&gt;pythonのthreadで引数を渡したい&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://d.hatena.ne.jp/salexkidd/20090918&#34;&gt;Djangoで時間のかかる処理をスレッド化して逃げ&lt;/a&gt;ようとしたのですがうまくいかなかったのでメモ。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;threading.Thread&lt;/code&gt;にはいくつか引数が渡せます。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;group&lt;/li&gt;
&lt;li&gt;target&lt;/li&gt;
&lt;li&gt;name&lt;/li&gt;
&lt;li&gt;args&lt;/li&gt;
&lt;li&gt;kwargs&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;詳しくは&lt;a href=&#34;http://docs.python.jp/2/library/threading.html&#34;&gt;ここ&lt;/a&gt;で。&lt;/p&gt;

&lt;p&gt;で、スレッド化したい処理に引数を渡そうと思って下記のように実装しました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def command_execute(cmd):
    print cmd # (&#39;s&#39;, &#39;l&#39;, &#39;e&#39;, &#39;e&#39;, &#39;p&#39;, &#39; &#39;, &#39;1&#39;, &#39;0&#39;, &#39;;&#39;, &#39;e&#39;, &#39;c&#39;, &#39;h&#39;, &#39;o&#39;, &#39; &#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;)
    subprocess.Popen(cmd, shell=True)
    return

cmd = &#39;sleep 10;echo aaa&#39;
t = threading.Thread(target=command_execute, args=(cmd))
t.daemon = True
t.start()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;すると、printされた文字列が
&lt;code&gt;(&#39;s&#39;, &#39;l&#39;, &#39;e&#39;, &#39;e&#39;, &#39;p&#39;, &#39; &#39;, &#39;1&#39;, &#39;0&#39;, &#39;;&#39;, &#39;e&#39;, &#39;c&#39;, &#39;h&#39;, &#39;o&#39;, &#39; &#39;, &#39;a&#39;, &#39;a&#39;, &#39;a&#39;)&lt;/code&gt;
となるわけです。
何が起きてるんだ状態です。&lt;/p&gt;

&lt;p&gt;調べてみると原因は「&lt;code&gt;args&lt;/code&gt;にtupleを渡してあげる」というところにありました。&lt;/p&gt;

&lt;h2 id=&#34;pythonでtupleをつくる&#34;&gt;pythonでtupleをつくる&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;tuple = (1, 2)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;基本はこれ。&lt;/p&gt;

&lt;p&gt;では、今回のように長さ1のtupleはどうやってつくるか&lt;/p&gt;

&lt;h2 id=&#34;長さ1のtuple&#34;&gt;長さ1のtuple&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;tuple = (1)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;普通のpythonist&lt;/strong&gt;であればこれは違うとわかるでしょうが、これだと思うでしょう？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tuple = (1)
print tuple # 1
print type(tuple) # &amp;lt;type &#39;int&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なんですよね。&lt;/p&gt;

&lt;h3 id=&#34;どうするのか&#34;&gt;どうするのか&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;tuple = (1,)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tuple = (1,)
print tuple # (1,)
print type(tuple) # &amp;lt;type &#39;tuple&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうでした。&lt;/p&gt;

&lt;h1 id=&#34;けっか&#34;&gt;けっか&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;def command_execute(cmd):
    print cmd # sleep 10;echo aaa
    subprocess.Popen(cmd, shell=True)
    return

cmd = &#39;sleep 10;echo aaa&#39;
t = threading.Thread(target=command_execute, args=(cmd,))
t.daemon = True
t.start()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうしてあげることによって期待通りの動きをしてくれました。&lt;/p&gt;

&lt;p&gt;tupleの作り方に注意しなさい的な記述をどこかで見たような気がしたのですが、すっかり失念しておりました。猛省。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>