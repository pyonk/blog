<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>django on わいがかいた</title>
    <link>https://pyonk.github.io/blog/tags/django/</link>
    <description>Recent content in django on わいがかいた</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 17 May 2020 11:28:16 +0900</lastBuildDate>
    
	<atom:link href="https://pyonk.github.io/blog/tags/django/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>pgcrypto for Django</title>
      <link>https://pyonk.github.io/blog/posts/pgcrypto-for-django/</link>
      <pubDate>Sun, 17 May 2020 11:28:16 +0900</pubDate>
      
      <guid>https://pyonk.github.io/blog/posts/pgcrypto-for-django/</guid>
      <description>Django, postgresで運用しているサービスで特定のカラムについて暗号化する必要が出てきたので調べてやってみました。
postgresの拡張機能であるpgcryptoで暗号化します。 https://www.postgresql.jp/document/10/html/pgcrypto.html
pgcryptoの有効化 後述の通りdjango-pgcrypto-fieldsを使う場合はmigrationファイルがよしなにやってくれるので必要ないけど
CREATE EXTENSION pgcrypto; /* 確認 */ SELECT * FROM pg_extentions; もしlib/pgcrypto.soがない場合は yum install postgresql-contribとかで用意しておく。
django-pgcrypto-fieldsのインストール Djangoとのやりとりはdjango-pgcrypto-fieldsを介して行うので インストールする。
pip install django-pgcrypto-fields 鍵の作成 pgcryptoには共通鍵暗号方式による暗号化と公開鍵暗号方式による暗号化があって
今回は公開鍵暗号方式を採用したの処理を怠るとので鍵を用意する必要がある。
鍵の作成方法はdocumentにも書いてある通りGnuPGを使用する。
以下のコマンドでインタラクティブに鍵が作成できる。
gpg --gen-key  推奨するキー種類は「DSAとElgamal」です。
― https://www.postgresql.jp/document/10/html/pgcrypto.html#id-1.11.7.35.7.19
 らしい。
* ssh経由で鍵を作成する際、エントロピー不足で鍵の作成に時間がかかる(もしくは終わらない)場合があるけどその場合はこれで解決した
作成できたら確認しよう。
gpg --list-secret-keys 確認時に表示される鍵IDで指定して公開鍵、秘密鍵をエクスポートする。
gpg -a --export KEYID &amp;gt; public.key gpg -a --export-secret-keys KEYID &amp;gt; private.key settingsに記述 ここまでで下準備が完了！
次はsettigns.pyに必要な記述をしていく。
PUBLIC_PGP_KEY_PATH, PRIVATE_PGP_KEY_PATH はさっき作成した鍵を指定する。
django-pgcrypto-fieldsの説明のまんまだけど
PUBLIC_PGP_KEY_PATH = os.path.abspath(os.path.join(BASEDIR, &amp;#39;public.key&amp;#39;)) PRIVATE_PGP_KEY_PATH = os.</description>
    </item>
    
    <item>
      <title>facebookのためにsocial loginをごにょごにょした話</title>
      <link>https://pyonk.github.io/blog/posts/social-login-update-for-facebook/</link>
      <pubDate>Wed, 20 Dec 2017 13:54:50 +0900</pubDate>
      
      <guid>https://pyonk.github.io/blog/posts/social-login-update-for-facebook/</guid>
      <description>facebookに見慣れぬアラートが。  突然のアラート    難しい英文    In 90 days, we&amp;rsquo;re making a security update to Facebook Login that will invalidate calls from URIs not listed in the Valid OAuth redirect URIs field of your Facebook Login settings.
This update comes in response to malicious activity we saw on our platform, and we want to protect your app or website by requiring a new strict mode for redirect URIs.</description>
    </item>
    
    <item>
      <title>djangoのquerysetを任意の順番でsortする</title>
      <link>https://pyonk.github.io/blog/posts/django-queryset-order-by-specific-values/</link>
      <pubDate>Fri, 10 Nov 2017 18:33:41 +0900</pubDate>
      
      <guid>https://pyonk.github.io/blog/posts/django-queryset-order-by-specific-values/</guid>
      <description>djangoのquerysetを任意の順番でsortする djnagoではorder_by(&#39;hoge&#39;)とするとhogeの昇順でならんでいくことは当たり前のように知っているよね。
が、ぼくがやりたかったのは、任意の値でのソート。
databaseに定義されてない値でソートしたかったのです。
とても参考になったstack overflowはこちら。
Django order_by specific order - Stack Overflow
 ただしdjango &amp;gt;= 1.8です
 TL;DR from djnago.db.models import Case, When, Value, FloatField # { pid: specific_value, } specific_values = { &amp;#39;1&amp;#39;: 100.0, &amp;#39;2&amp;#39;: 50.0, &amp;#39;3&amp;#39;: 25.0, &amp;#39;4&amp;#39;: 123.4, &amp;#39;5&amp;#39;: 599.33, } # sqlのCASE式にしたい条件のリスト cases = [] # casesにCASE式にしたい条件をつめていく for pid, specific_value in specific_values.items(): cases.append(When(id=pid, then=Value(specific_value))) # Hogeモデルに対して、pidで絞り込んだあとにcasesをつかってspecific_valueについて注釈づけてorder_byする Hoge.objects.filter(id__in=specific_values.keys()).annotate(specific_value=Case( *cases, output_field=FloatField() )).order_by(specific_value) 詳しい説明 Conditional Expressions | Django documentation | Django</description>
    </item>
    
    <item>
      <title>Djangoでどうしても非同期でコマンドを実行したくなった</title>
      <link>https://pyonk.github.io/blog/posts/use-celery-for-send-email-django/</link>
      <pubDate>Fri, 06 Jan 2017 12:05:29 +0900</pubDate>
      
      <guid>https://pyonk.github.io/blog/posts/use-celery-for-send-email-django/</guid>
      <description>経緯 あるサイトで、顧客に新情報をメールでお知らせしたいときに、今まではコマンド叩いて送信していたのですが、結構面倒なのでブラウザからできないものかと試行錯誤していたのです。
コマンドの設計見直せっていうのは今回は置いといてください・・・。
どうしたのか いくつかの方法を試しました。
pythonからコマンドを叩く まず思い浮かんだのがコマンドをnohup &amp;amp;でpythonから叩く。
import subprocess import shlex cmd = &amp;#39;nohup sleep 10 &amp;amp;&amp;#39; subprocess.Popen(cmd) が！！！ レスポンスが帰ってくるのは10秒後・・・。
つぎ！
thread化して逃げる この前書いたような感じです。
pythonでtupleをつくる - わいがかいた
結局、レスポンスが帰ってくるのは10秒後・・・。 ここ工夫するとどうにかなるような気もする。
つぎ！！
celeryを使う Celery - Distributed Task Queue — Celery 4.0.2 documentation
ようやく本題。
ググり始めた当初から名前を見かけてはいましたが敷居が高そうなのでスルーしてました。
実際やりはじめて少し後悔しましたし。
結構面倒くさかったので備忘録代わりに。
install まずは本体をインストールしていきます。
pip install -U Celery
celeryはbrokerとして
 Redis RabbitMQ Amazon SQS  などを使うことができます。 今回はRedisを選択しました。
yum install redis
bundleも用意されているのでそれも。
pip install -U &amp;quot;celery[redis]&amp;quot;
how to ここを参考にモリモリかいていきます。</description>
    </item>
    
  </channel>
</rss>